# Makefile
# 张沛全 3190102214

CC = gcc
OBJECTS = main.o input.o compute.o
SOURCES = main.c input.c compute.c
TARGET = power
# HEADERS = 
$(TARGET): $(OBJECTS)
	$(CC) $(OBJECTS) -o $(TARGET) -lm
main.o: main.c main.h compute.h input.h
	$(CC) -c main.c
input.o: input.c input.h
	$(CC) -c input.c
compute.o: compute.c compute.h
	$(CC) -c compute.c
clean: 
	rm $(OBJECTS) $(TARGET)

#! /usr/bin/bash
# stat.sh
# 张沛全 3190102214

# 检查传入参数的数量
if [ $# -ne 1 ]
then
    echo "The number of variabls is wrong!"
    exit 1
fi

# 检查输入的目录是否存在
if [ ! -d "$1" ]
then
    echo "The directory does not exist!"
    exit 1
fi

# 初始化数据
rf=0
df=0
xf=0
size=0
# 跳至目标目录下，方便进行遍历，同时也支持输入相对路径和绝对路径
cd $1
for filee in `ls $1`
do
echo $filee
if [ -f "$filee" ]; then    # 普通文件
    rf=`expr $rf + 1`
    info=`wc -c $filee` # 得到大小
    info=(${info[@]})
    size=`expr $size + ${info[0]}`
fi
if [ -d "$filee" ]; then    # 目录文件
    df=`expr $df + 1`
fi
if [ -f "$filee" ] && [ -x "$filee" ]; then # 可执行文件
    xf=`expr $xf + 1`
fi
done
echo "regular files:$rf"
echo "directories:$df"
echo "executable files:$xf"
echo "size of regular files:$size"
exit 0

#! /usr/bin/bash
# palindrome.sh
# 张沛全 3190102214

# 检查传入参数的数量
if [ $# -ne 1 ]
then
    echo "The number of variabls is wrong!"
    exit 1
fi

origin=$1   # 取得原输入
str=${origin//[^a-zA-Z]/}   # 去除非字母
# echo $str
left=0
right=$[${#str}-1]  # 计算长度
# let "right--"   
while [ $left -lt $right ]; do
    if [ ${str:$left:1} != ${str:$right:1} ]; then  # 不是回文
        echo "It is NOT a palindrome!"
        exit 1
    fi
    let "left++"
    let "right--"
done
echo "It is a palindrome!"  # 能执行到这一步的一定是回文
exit 0

#! /usr/bin/bash
# dirsync.sh
# 张沛全 3190102214

dirsyn(){
    # 写一个递归的程序
    # 写的时候发现好像不能直接把两个文件名定义成变量，父进程的变量值居然是子进程的
    touch "/tmp/.source_files_$3"
    touch "/tmp/.target_files_$3"
    # 获取文件名并排序
    cd "$1"
    ls | sort >"/tmp/.source_files_$3"
    cd "$2"
    ls | sort >"/tmp/.target_files_$3"
    # 这一个循环处理应该添加到仓库里的文件
    for file in $(comm -23 "/tmp/.source_files_$3" "/tmp/.target_files_$3"); do
        if [ -d $1'/'$file ]
            then
                # 该文件是一个文件夹
                # echo "a directory"
                mkdir $2'/'$file
                # 既然该文件夹是新的，说明里面的内容也没有备份过，因此直接用cp命令
                dirsyn $1'/'$file $2'/'$file $(($3+1))
            else
                # echo "a file"
                cp $1'/'$file $2'/'$file
        fi
    done
    # 这一个循环处理应该从仓库里删除的文件
    for file in $(comm -13 "/tmp/.source_files_$3" "/tmp/.target_files_$3"); do
        # echo rm $2'/'$file
        rm -fr $2'/'$file
    done
    # 这一个循环处理应该双向同步的文件
    for file in $(comm -12 "/tmp/.source_files_$3" "/tmp/.target_files_$3"); do
        # 获取修改时间
        sourcetime=$(stat $1'/'$file -c %Y)
        targettime=$(stat $2'/'$file -c %Y)
        if [ -d $1'/'$file ]
            then
                # 源文件是一个目录
                if [ ! -d $2'/'$file ]
                    then
                        # 仓库中的对应文件不是目录，文件类型不一致时把仓库里面的更新掉
                        rm $2'/'$file
                        mkdir $2'/'$file
                        dirsyn $1'/'$file $2'/'$file $(($3+1))
                    elif [ $sourcetime -lt $targettime ]; then
                        # 更新源文件
                        dirsyn $2'/'$file $1'/'$file $(($3+1))
                    elif [ $sourcetime -gt $targettime ]; then
                        # 更新仓库文件
                        dirsyn $1'/'$file $2'/'$file $(($3+1))
                fi
            else
                # 源文件是一个文件
                if [ -d $2'/'$file ]
                    then
                        # 仓库中的对应文件是目录，文件类型不一致时把仓库里面的更新掉
                        rmdir $2'/'$file
                        cp $1'/'$file $2'/'$file
                    elif [ $sourcetime -lt $targettime ]; then
                        # 更新源目录
                        cp $2'/'$file $1'/'$file
                    elif [ $sourcetime -gt $targettime ]; then
                        # 更新仓库中的目录
                        cp $1'/'$file $2'/'$file
                fi
        fi
    done
    rm "/tmp/.source_files_$3"
    rm "/tmp/.target_files_$3"
}

# 检查传入参数的数量
if [ $# -ne 2 ]
then
    echo "The number of variabls is wrong!"
    exit 1
fi

# 检查输入的目录是否存在
if [ ! -d "$1" ]
then
    echo "The source directory does not exist!"
    exit 1
fi
if [ ! -e "$2" ]
then
    echo "The backup directory does not exist and is created!"
    mkdir $2
fi

# 获取路径
cpath=$(pwd)
cd $1
sourcepath=$(pwd)
cd $cpath
cd $2
targetpath=$(pwd)
cd $cpath
# 调用函数
dirsyn $sourcepath $targetpath 1
echo "Synchronization completes!"
exit 0

# bash dirsync.sh source/ backup/

#! /usr/bin/bash
# poker.sh
# 张沛全 3190102214

# 初始化函数
init(){
    # 初始化牌
    for ((i=0;i<4;i++)); do
        for ((j=0;j<13;j++)); do
            cards[$((i*13+j))]="${size[$j]} ${rank[$i]}"
        done
    done
    # 初始化每个牌的大小权重，保存在order数组中，方便比较大小
    for ((i=0;i<13;i++)); do
        for ((j=0;j<4;j++)); do
            index="${size[$i]} ${rank[$j]}"
            order[$index]=$((i*4+j))
        done
    done
    score[0]=0
    score[1]=0
    score[2]=0
    score[3]=0
    id[0]="player0"
    id[1]="player1"
    id[2]="player2"
    id[3]="player3"
    # 玩家输入id
    for ((i=0;i<4;i++)); do
        if [ $i -eq 0 ]; then
            printf "You can enter the name for the %s player (default 'player%d') :" first 0
        elif [ $i -eq 1 ]; then
            printf "You can enter the name for the %s player (default 'player%d') :" second 1
        elif [ $i -eq 2 ]; then
            printf "You can enter the name for the %s player (default 'player%d') :" third 2
        else
            printf "You can enter the name for the %s player (default 'player%d') :" fourth 3
        fi
        read idinput
        if [[ "$idinput" ]]; then
            id[i]="$idinput"
        fi
    done
    # for ((i=0;i<13;i++)); do
    #     for ((j=0;j<4;j++)); do
    #         index="${size[$i]} ${rank[$j]}"
    #         echo "$index: ${order[$index]}"
    #     done
    # done
}

# 洗牌函数
shuffle(){
    for ((i=0;i<52;i++)); do
        # 生成随机数
        index=$(date +%N)
        index=$(((10#$index*48271+47)%52))
        x=${cards[i]}
        cards[$i]=${cards[$index]}
        cards[$index]=$x
    done
    # 发牌
    for ((i=0;i<13;i++)); do
        cards0[$i]=${cards[i]}
    done
    for ((i=0;i<13;i++)); do
        cards1[$i]=${cards[13+i]}
    done
    for ((i=0;i<13;i++)); do
        cards2[$i]=${cards[26+i]}
    done
    for ((i=0;i<13;i++)); do
        cards3[$i]=${cards[39+i]}
    done
}

# 打印玩家手头的牌
display(){
    # 打印四个玩家拥有的牌
    if [ $# -eq 0 ]; then
        echo "--------Now each player has--------"
        echo "- ${id[0]}: "
        for ((i=0;i<13;i++)); do
            if [[ ${cards0[$i]} ]]; then
                echo -n "${cards0[$i]}   "
            fi
        done
        echo ""
        echo "- ${id[1]}: "
        for ((i=0;i<13;i++)); do
            if [[ ${cards1[$i]} ]]; then
                echo -n "${cards1[$i]}   "
            fi
        done
        echo ""
        echo "- ${id[2]}: "
        for ((i=0;i<13;i++)); do
            if [[ ${cards2[$i]} ]]; then
                echo -n "${cards2[$i]}   "
            fi
        done
        echo ""
        echo "- ${id[3]}: "
        for ((i=0;i<13;i++)); do
            if [[ ${cards3[$i]} ]]; then
                echo -n "${cards3[$i]}   "
            fi
        done
        echo ""
        echo "--------done--------"
    elif [ $1 -eq 0 ]; then
        echo "- ${id[0]}: "
        for ((i=0;i<13;i++)); do
            if [[ ${cards0[$i]} ]]; then
                echo -n "${cards0[$i]}   "
            fi
        done
        echo ""
    elif [ $1 -eq 1 ]; then
        echo "- ${id[1]}: "
        for ((i=0;i<13;i++)); do
            if [[ ${cards1[$i]} ]]; then
                echo -n "${cards1[$i]}   "
            fi
        done
        echo ""
    elif [ $1 -eq 2 ]; then
        echo "- ${id[2]}: "
        for ((i=0;i<13;i++)); do
            if [[ ${cards2[$i]} ]]; then
                echo -n "${cards2[$i]}   "
            fi
        done
        echo ""
    elif [ $1 -eq 3 ]; then
        echo "- ${id[3]}: "
        for ((i=0;i<13;i++)); do
            if [[ ${cards3[$i]} ]]; then
                echo -n "${cards3[$i]}   "
            fi
        done
        echo ""
    fi
    # sleep 10s
}

# 用于比较两个牌的大小，前者大则返回1
cmp(){
    if [ ${order[$1]} -ge ${order[$2]} ]; then
        return 1
    else
        return 0
    fi
}

# 每个玩家出牌的函数，输入参数为玩家的编号
play(){
    echo "It's ${id[$1]}'s turn"
    # 先展示有什么牌
    display $1
    # 出牌
    while [ true ]; do
        # 获取玩家输入
        echo -n "Please enter the card you want to play: "
        read card2play
        if [ $1 -eq 0 ]; then
            # card2play="${cards0[$k]}"
            for ((i=0;i<13;i++)); do
                if [[ ${cards0[$i]} = $card2play ]]; then
                    pool[0]=${cards0[$i]}
                    unset cards0[$i]
                    clear
                    return 0
                fi
            done
            echo "You cannot play this card! Please enter again! "
        elif [ $1 -eq 1 ]; then
            # card2play="${cards1[$k]}"
            for ((i=0;i<13;i++)); do
                if [[ ${cards1[i]} = $card2play ]]; then
                    pool[1]=${cards1[i]}
                    unset cards1[$i]
                    clear
                    return 0
                fi
            done
            echo "You cannot play this card! Please enter again! "
        elif [ $1 -eq 2 ]; then
            # card2play="${cards2[$k]}"
            for ((i=0;i<13;i++)); do
                if [[ ${cards2[i]} = $card2play ]]; then
                    pool[2]=${cards2[i]}
                    unset cards2[$i]
                    clear
                    return 0
                fi
            done
            echo "You cannot play this card! Please enter again! "
        elif [ $1 -eq 3 ]; then
            # card2play="${cards3[$k]}"
            for ((i=0;i<13;i++)); do
                if [[ ${cards3[i]} = $card2play ]]; then
                    pool[3]=${cards3[i]}
                    unset cards3[$i]
                    clear
                    return 0
                fi
            done
            echo "You cannot play this card! Please enter again! "
        fi
    done
}

# 对于每一张牌，与其后面的牌比较一次，大于则计一分，这样则可以利用下标来记录总得分
judge(){
    # 计分
    for ((i=0;i<3;i++)); do
        for ((j=i+1;j<4;j++)); do
            cmp "${pool[$i]}" "${pool[$j]}"
            if [ $? -eq 1 ]; then
                let "score[$i]+=2"
            else 
                let "score[$j]+=2"
            fi
        done
    done
}


#############主函数#############
# 检查传入参数的数量
if [ $# -eq 1 ]; then
    # echo "$1"
    if [ $1 = "--help" ]; then
        echo "--------This is a game developed by zpq--------"
        echo "Rules: "
        echo "1. The four palyers will be distributed 13 cards respectively"
        echo "2. In each round, each player plays a card and earns a score of 4, 3, 2 or 1 according to the order of the four cards"
        echo "3. The order is determined by: A>K>Q>J>10>9>8>7>6>5>4>3>2 and Spade>Heart>Club>Diamond"
        echo "4. After all the cards are played, the player with the highest score wins"
        exit 0
    else
        echo "Illegal varibale!"
        exit 1
    fi
elif [ $# -ne 0 ]; then
    echo "The number of variabls is wrong!"
    exit 1
fi

# 打印信息
echo "Welcome to A Comparison Game!"
# 声明
declare -a cards
declare -a cards0
declare -a cards1
declare -a cards2
declare -a cards3
declare -a pool
declare -a score
declare -a id
declare -A order
# 考虑加入自定义玩家名
# 初始化牌的花色与大小
rank=("Diamond" "Club" "Heart" "Spade")
size=(2 3 4 5 6 7 8 9 10 J Q K A)
init
shuffle
# 出牌13轮
for ((k=0;k<13;k++)); do
    index=$(date +%N)
    index=$(((10#$index*48271+47)%52/13))
    play $index
    index=$((($index+1)%4))
    play $index
    index=$((($index+1)%4))
    play $index
    index=$((($index+1)%4))
    play $index
    index=$((($index+1)%4))
    judge
    echo "--------Score--------"
    echo "${id[0]}: ${score[0]}"
    echo "${id[1]}: ${score[1]}"
    echo "${id[2]}: ${score[2]}"
    echo "${id[3]}: ${score[3]}"
    echo "---------------------"
    sleep 3s
    clear
done
# echo "0: ${score[0]}"
# echo "1: ${score[1]}"
# echo "2: ${score[2]}"
# echo "3: ${score[3]}"
# 获取结果并输出
if [ ${score[0]} -gt ${score[1]} ] && [ ${score[0]} -gt ${score[2]} ] && [ ${score[0]} -gt ${score[3]} ]; then
    echo "${id[0]} wins!!"
elif [ ${score[1]} -gt ${score[0]} ] && [ ${score[1]} -gt ${score[2]} ] && [ ${score[1]} -gt ${score[3]} ]; then
    echo "${id[1]} wins!!"
elif [ ${score[2]} -gt ${score[0]} ] && [ ${score[2]} -gt ${score[1]} ] && [ ${score[2]} -gt ${score[3]} ]; then
    echo "${id[2]} wins!!"
elif [ ${score[3]} -gt ${score[0]} ] && [ ${score[3]} -gt ${score[2]} ] && [ ${score[3]} -gt ${score[2]} ]; then
    echo "${id[3]} wins!!"
else 
    echo "There is no winners!!"
fi
exit 0

// base.h
// 张沛全 3190102214

#ifndef BASE_H
#define BASE_H

// 颜色 特殊值 命令的标志位
#define GOON 0
#define LOGOUT 1
#define FG 0
#define BG 1
#define RUNNING 0
#define SUSPEND 1
#define DONE 2
#define MAX_JOB 128
#define IN_RD 1
#define OUT_RD 2
#define OUT_RD_APP 4
#define ERR_RD 8
#define ERR_RD_APP 16
#define IS_PIPE 32
#define IS_BG 64
#define CANCEL "\e[0m"
#define RED "\e[1;31m"
#define GREEN "\e[0;32m"
#define YELLOW "\e[1;33m"
#define BLUE "\e[1;34m"
#define PURPLE "\e[1;35m"
#define CYAN "\e[1;36m"
#define WHITE "\e[1;37m"
#define CLEAR "\e[1;1H\e[2J"


#endif
// commands.h
// 张沛全 3190102214

#ifndef COMMANDS_H
#define COMMANDS_H

#include<iostream>
#include<sstream>
#include<unistd.h>
#include<stdlib.h>
#include<time.h>
#include<cstring>
#include<vector>
#include<dirent.h>
#include<sys/stat.h>
#include<sys/shm.h>
#include<sys/types.h>
#include<sys/wait.h>
#include<pwd.h>
#include<grp.h>
#include"base.h"

// 进程信息结构体
typedef struct job
{
    pid_t pid; 
    std::string name; 
    int type; 
    int status; 
}job;

/* backup functions */
// 信号处理函数，处理SIGCHLD与SIGTSTP
void signal_handler(int signum, siginfo_t *siginfo, void *context); 
// 添加一个进程
job* addjob(pid_t pid, std::string &jobname, int type, int status); 
// 删除一个进程
void removejob(pid_t pid); 
// 初始化进程表
void init_jobs(); 
// 释放进程表
void free_jobs(); 
// 判断一个字符串是否为纯数字
int is_digit(const std::string &str); 
// 将相对路径转化为绝对路径
void rtoa_path(std::string &dir, const std::string &input); 
// 打印一个文件的详细信息，参考了ls -l命令
void dir_l(const std::string &entry); 
/* built-in commands */
void f_jobs(int index, int length);
void f_fg(int index, int length);
void f_bg(int index, int length);
void f_dir(int index, int length); 
void f_set(int index, int length);
void f_unset(int index, int length);
void f_umask(int index, int length);
void f_exec(int index, int length);
void f_test(int index, int length);
void f_shift(int index, int length);
void f_time(int index, int length);
void f_pwd(int index, int length);
void f_echo(int index, int length);
void f_cd(int index, int length);
void f_exit(int index, int length);
void f_clr(int index, int length);
void f_system(int index, int length);
void f_help(int index, int length);
#endif
// myshell.h
// 张沛全 3190102214

#ifndef MYSHELL_H
#define MYSHELL_H

#include<iostream>
#include<sstream>
#include<string>
#include<unistd.h>
#include<stdlib.h>
#include<algorithm>
#include<vector>
#include<pwd.h>
#include<string.h>
#include<sys/utsname.h>
#include<sys/wait.h>
#include<signal.h>
#include<stddef.h>
#include"base.h"

// 打印提示信息
void showprompt(); 
// 翻译输入的命令并选择执行
int interpreter(char *cmd_char); 
// 初始化函数
void init(); 
// 执行内部命令并返回0，当命令为外部命令时返回-1
int execute_builtin(int index, int length); 
// 执行命令
void execute(int index, int length); 
// 递归执行带有管道的命令
void executepipe(int flag, std::vector<std::pair<int, int>>&cmdinfo, int level);
#endif
// commands.cpp
// 张沛全 3190102214

#include"base.h"
#include"commands.h"

// 声明myshell.cpp中的变量
extern job* jobs;
extern int* jobnum;
extern int shmID;
extern std::vector<std::string> cmdlist; 

/* backup functions */
// 信号处理函数，处理SIGCHLD与SIGTSTP
void signal_handler(int signum, siginfo_t *siginfo, void *context){
    const int job_num = *jobnum; 
    int i, bgid = 0; 
    pid_t pid = siginfo->si_pid; 
    pid_t mainpid = jobs[0].pid; 
    if(signum == SIGCHLD && waitpid(-1, NULL, WNOHANG|WUNTRACED) && getpid() == mainpid){
        // 处理结束信号，一定要判断子进程的状态
        // 为什么判断getpid()的值：因为实际上的调用是创建了一个新的myshell进程，myshell进程又创建了一个sh进程，sh进程还要再创建一个进程来调用命令
        // 如果不判断是否为主进程收到信号，这个函数会被多次触发
        for(i=0; i<job_num; i++){
            if(jobs[i].type == BG){
                bgid++; 
            }
            if(pid == jobs[i].pid){
                break; 
            }
        }
        if(i<job_num){
            // 找到
            if(jobs[i].type == BG){
                if(jobs[i].status == RUNNING){
                    jobs[i].status = DONE; 
                    // std::cout << WHITE << "\n[" << bgid+1 << "]  DONE\t\t" << jobs[i].name << std::endl; 
                }
                else if(jobs[i].status == SUSPEND){
                    ; 
                }
                else{
                    removejob(pid);
                    ;  
                }
            }
            else{
                if(jobs[i].status == RUNNING){
                    jobs[i].status = DONE; 
                    jobs[i].type = BG; 
                }
            }
        }
    } 
    // 处理中断挂起 ^Z
    else if(signum == SIGTSTP && getpid() == mainpid){
        int lastFG = 0, id, bgid = 0; 
        std::string name;
        pid_t pid;  
        // 寻找该进程
        for(i=0; i<job_num; i++){
            if(jobs[i].type == BG){
                bgid++; 
            }
            else{
                if(jobs[i].name != "myshell"){
                    id = bgid + 1; 
                    lastFG = i; 
                    name.append(jobs[i].name); 
                    pid = jobs[i].pid; 
                    break; 
                }
            }
        }
            
        if(lastFG>0){
            // 找到了该进程
            std::cout << WHITE << "\n[" << id << "]  Stopped\t\t" << pid << "\t" << name << std::endl; 
            jobs[lastFG].type = BG; 
            jobs[lastFG].status = SUSPEND; 
            kill(pid, SIGSTOP); 
        }
    }
}

// 添加一个进程
job* addjob(pid_t pid, std::string &jobname, int type, int status){
    int job_num = *jobnum; 
    if(job_num == MAX_JOB){
        fprintf(stderr,  RED "myshell: Too many jobs\n"); 
        free_jobs(); 
        exit(1); 
    }
    jobs[job_num].pid = pid; 
    jobs[job_num].name = jobname; 
    // strcpy(jobs[job_num].name, jobname.c_str()); 
    jobs[job_num].type = type; 
    jobs[job_num].status = status;
    *jobnum = job_num + 1; 
    return &jobs[job_num];  
}

// 删除一个进程
void removejob(pid_t pid){
    int i, job_num = *jobnum; 
    // 在表中寻找该进程
    for(i=0; i<job_num; i++){
        if(pid == jobs[i].pid){
            break; 
        }
    }

    if(i < job_num - 1){
        // 找到
        for( ; i<job_num-1; i++){
            jobs[i].pid = jobs[i+1].pid; 
            jobs[i].name = jobs[i+1].name;  
            jobs[i].type = jobs[i+1].type; 
            jobs[i].status = jobs[i+1].status; 
        }
    }
    // 修改信息
    jobs[i].pid = -1; 
    *jobnum = job_num - 1; 
}

// 初始化进程表
void init_jobs(){
    // 创建共享内存，返回值为-1则创建失败
    if((shmID = shmget((key_t)4399, sizeof(job)*MAX_JOB+sizeof(int), 0666|IPC_CREAT)) == -1){
        fprintf(stderr,  RED "myshell: Fail to create shared memory\n"); 
        exit(1); 
    }
    // 连接共享内存
    void *mem = shmat(shmID, 0, 0); 
    if(mem == (void *)-1){
        fprintf(stderr,  RED "myshell: Fail to connect to shared memory\n"); 
        exit(1); 
    }
    else{
        jobs = (job*)mem; 
    }
    
    // 初始化
    for(int i=0; i<MAX_JOB; i++){
        jobs[i].pid = -1; 
    }

    // 把当前进程myshell加进去
    std::string myshell = "myshell"; 
    jobnum = (int *)((char *)mem + sizeof(jobs)*MAX_JOB); 
    *jobnum = 0; 
    addjob(getpid(), myshell, FG, RUNNING); 
}

// 释放进程表
void free_jobs(){
    // 断开连接
    if(shmdt((void *)jobs) == -1){
        fprintf(stderr,  RED "myshell: Fail to detach shared memory segment\n"); 
        exit(1); 
    }
    // 释放共享内存
    if(shmctl(shmID, IPC_RMID, 0) == -1){
        fprintf(stderr,  RED "myshell: Fail to free shared memory segment\n"); 
        exit(1); 
    }
}

// 判断一个字符串是否为纯数字
int is_digit(const std::string &str){
    int length = str.length();
    for(int i=0; i<length; i++){
        if(str[i]<'0' || str[i]>'9'){
            // 发现非数字则返回0
            return 0; 
        }
    } 
    return 1; 
}

// 将相对路径转化为绝对路径
void rtoa_path(std::string &dir, const std::string &input){
    dir = input; 
    if(dir[0] == '~'){
        // 主目录
        extern std::string home; 
        dir.replace(0, 1, home); 
    }
    else if(dir.substr(0, 2) == ".."){
        // 父目录
        dir = getenv("PWD"); 
        if(dir.rfind('/') == 0){
            if(dir.length() == 0){
                // 已经到达根目录
                dir = dir; 
            }
            else {
                dir = dir.substr(0, 1); 
            }
        }
        else {
            dir = dir.substr(0, dir.rfind('/')); 
        }
        if(input.length() > 2){
            dir.append(input.substr(2, input.length()-2)); 
        }
    }
    else if(dir[0] == '.'){
        // 当前目录
        dir = getenv("PWD"); 
        if(input.length() > 1){
            dir.append(input.substr(1, input.length()-1)); 
        }
    }
    else if(dir[0] != '/'){
        // 根目录
        dir = getenv("PWD");
        dir.append("/"); 
        dir.append(input);  
    }
}

// 打印一个文件的详细信息，参考了ls -l命令
void dir_l(const std::string &entry){
    struct stat entrystatus; 
    std::string path; 
    rtoa_path(path, entry); 
    stat(path.c_str(), &entrystatus); 
    // 判断文件类型
    std::string mask; 
    switch (entrystatus.st_mode & S_IFMT){
        case S_IFREG:
            // 普通文件
            mask.append("-"); 
            break;
        case S_IFDIR:
            // 目录文件
            mask.append("d"); 
            break;
        case S_IFIFO:
            // 管道文件
            mask.append("p"); 
            break;
        case S_IFLNK:
            // 软连接
            mask.append("l"); 
            break;
        case S_IFSOCK:
            // 套接字文件
            mask.append("s"); 
            break;
        case S_IFBLK:
            // 块设备文件
            mask.append("b"); 
            break;
        case S_IFCHR:
            // 字符设备文件
            mask.append("c"); 
            break;
        default:
            mask.append("-");
            break;
    }
    // 判断文件权限
    mask.append((entrystatus.st_mode & S_IRUSR) ? "r" : "-"); 
    mask.append((entrystatus.st_mode & S_IWUSR) ? "w" : "-"); 
    mask.append((entrystatus.st_mode & S_IXUSR) ? "x" : "-"); 
    mask.append((entrystatus.st_mode & S_IRGRP) ? "r" : "-"); 
    mask.append((entrystatus.st_mode & S_IWGRP) ? "w" : "-"); 
    mask.append((entrystatus.st_mode & S_IXGRP) ? "x" : "-"); 
    mask.append((entrystatus.st_mode & S_IROTH) ? "r" : "-"); 
    mask.append((entrystatus.st_mode & S_IWOTH) ? "w" : "-"); 
    mask.append((entrystatus.st_mode & S_IXOTH) ? "x" : "-"); 
    // 硬连接
    int nlink = entrystatus.st_nlink; 
    // 用户与所属组
    std::string user = getpwuid(entrystatus.st_uid)->pw_name; 
    std::string group = getgrgid(entrystatus.st_uid)->gr_name; 
    // 大小
    int size = (int)entrystatus.st_size; 
    // 修改时间
    std::string mo_time = ctime(&entrystatus.st_mtime);  
    mo_time.replace(mo_time.find('\n'), 1, ""); 

    std::cout << mask << " " << nlink << "\t\t" << user << "\t"; 
    std::cout << group << "\t" << size << "\t" << mo_time << " " << entry << std::endl; 
}

/* bg、cd 、clr、dir、echo 、exec 、exit 、fg 、help、jobs 、pwd 、set 、shift 、test 、time 、umask、unset */
void f_jobs(int index, int length){
    const int job_num = *jobnum; 
    if(length>1){
        fprintf(stderr,  RED "myshell: jobs: Too many arguments\n"); 
    }
    else {
        int bg_id = 0; 
        // 要删除的进程的表
        std::vector<pid_t> remove_list; 
        std::cout << "\tPID" << "\tstatus" << "\tname" << std::endl; 
        for (int i = 0; i < job_num; i++)
        {
            if(jobs[i].type == BG){
                std::cout << '[' << ++bg_id << "]\t" << jobs[i].pid << "\t"; 
                if(jobs[i].status == RUNNING){
                    std::cout << "RUNNING\t"; 
                }
                else if(jobs[i].status == SUSPEND){
                    std::cout << "SUSPEND\t"; 
                }
                else{
                    remove_list.push_back(jobs[i].pid); 
                    std::cout << "DONE\t"; 
                }
                std::cout << jobs[i].name << std::endl; 
            }
        }
        // 状态为DONE的进程，输出一次后删除
        for (int i = 0; i < remove_list.size(); i++){
            removejob(remove_list[i]); 
        }
    } 
}

void f_fg(int index, int length){
    const int job_num = *jobnum; 
    if(length == 1){
        fprintf(stderr,  RED "myshell: fg: Too few arguments\n");
    }
    else if(length > 2){
        fprintf(stderr,  RED "myshell: fg: Too many arguments\n");
    }
    else{
        if(!is_digit(cmdlist[index+1])){
            fprintf(stderr,  RED "myshell: fg: %s: Numeric pid required\n", cmdlist[index+1].c_str());
        }
        else{
            int i, ret; 
            pid_t target = atoi(cmdlist[index+1].c_str()); 
            // 寻找该进程
            for(i=0; i<job_num; i++){
                if(jobs[i].pid == target){
                    break; 
                }
            }
            if(i<job_num){
                // 找到了 
                if(jobs[i].type == BG){
                    std::cout << WHITE << jobs[i].name << std::endl; 
                    if(jobs[i].status == RUNNING){
                        // 正在后台运行
                        jobs[i].type = FG; 
                        waitpid(jobs[i].pid, &ret, 0); 
                    }
                    else if(jobs[i].status == SUSPEND){
                        // 正在后台挂起
                        jobs[i].type = FG; 
                        jobs[i].status = RUNNING; 
                        // 发出信号让进程继续运行
                        // 实际这里存的是myshell的pid，恢复时先继续myshell，再继续sh，最后继续命令
                        kill(jobs[i].pid, SIGCONT); 
                        kill(jobs[i].pid+1, SIGCONT); 
                        kill(jobs[i].pid+2, SIGCONT); 
                        waitpid(jobs[i].pid, &ret, 0); 
                    }
                    else{
                        // 已经完成
                        fprintf(stderr,  RED "myshell: fg: %d: Process already done\n", target);
                    }
                }
                else{
                    fprintf(stderr,  RED "myshell: fg: %d: Foreground process\n", target);
                }
            }
            else{
                fprintf(stderr,  RED "myshell: fg: %d: No such process\n", target);
            }
        }
    }
}

void f_bg(int index, int length){
    const int job_num = *jobnum; 
    if(length == 1){
        fprintf(stderr,  RED "myshell: bg: Too few arguments\n");
    }
    else if(length > 2){
        fprintf(stderr,  RED "myshell: bg: Too many arguments\n");
    }
    else{
        if(!is_digit(cmdlist[index+1])){
            fprintf(stderr,  RED "myshell: bg: %s: Numeric pid required\n", cmdlist[index+1].c_str());
        }
        else{
            int i, ret, bgid = 0; 
            pid_t target = atoi(cmdlist[index+1].c_str()); 
            // 寻找该进程
            for(i=0; i<job_num; i++){
                if(jobs[i].type == BG){
                    bgid++; 
                }
                if(jobs[i].pid == target){
                    break; 
                }
            }
            if(i<job_num){
                // 找到了 
                if(jobs[i].type == BG){
                    if(jobs[i].status == RUNNING){
                        // 正在后台运行
                        fprintf(stderr,  RED "myshell: bg: %d: Running process\n", target);
                    }
                    else if(jobs[i].status == SUSPEND){
                        // 正在后台挂起
                        std::cout << WHITE << '[' << bgid << "]\t" << jobs[i].pid; 
                        std::cout << "\tStopped\t\t" << jobs[i].name << std::endl; 
                        jobs[i].status = RUNNING; 
                        // 发出信号让进程继续运行
                        // 实际这里存的是myshell的pid，恢复时先继续myshell，再继续sh，最后继续命令
                        kill(jobs[i].pid, SIGCONT); 
                        kill(jobs[i].pid+1, SIGCONT); 
                        kill(jobs[i].pid+2, SIGCONT); 
                    }
                    else{
                        // 已经完成
                        fprintf(stderr,  RED "myshell: bg: %d: Process already done\n", target);
                    }
                }
                else{
                    fprintf(stderr,  RED "myshell: bg: %d: Foreground process\n", target);
                }
            }
            else{
                fprintf(stderr,  RED "myshell: bg: %d: No such process\n", target);
            }
        }
    }
}

void f_dir(int index, int length){
    DIR *dp; 
    struct dirent *entry;
    std::string directory; 

    if(length < 3){
        if(length == 1){
            directory = getenv("PWD"); 
        }
        else {
            if(cmdlist[index+1] == "-l"){
                // 参数中含有-l
                directory = getenv("PWD"); 
                dp = opendir(directory.c_str()); 
                while (entry = readdir(dp)){
                    if(std::string(entry->d_name)!="." && std::string(entry->d_name)!=".."){
                        // 输出详细信息
                        dir_l(std::string(entry->d_name));
                    }
                }
                return ;
            }
            else{
                // 输入的一个参数为一个路径
                directory = cmdlist[index+1]; 
            }
        }
        if(dp = opendir(directory.c_str())){
            // 目录存在且可以打开
            while (entry = readdir(dp)){
                if(std::string(entry->d_name)!="." && std::string(entry->d_name)!=".."){
                    std::cout << entry->d_name << "\t"; 
                }
            }
            std::cout << std::endl; 
            closedir(dp); 
        }
        else{
            fprintf(stderr, RED "myshell: dir: %s: No such directory or permission denied\n", cmdlist[index+1].c_str()); 
        }
    }
    else{
        // 多个参数
        // 检查是否输入了-l
        int lflag = 0; 
        for(int i=1; i<length; i++){
            if(cmdlist[index+i] == "-l"){
                lflag = 1; 
                break; 
            }
        }
        for (int i=1; i<length; i++){
            if(cmdlist[index+i] != "-l"){
                std::cout << cmdlist[index+i] << ":" << std::endl; 
                if(lflag){
                    // 输出详细信息
                    directory = cmdlist[index+i];
                    rtoa_path(directory, cmdlist[index+i]); 
                    if(!chdir(directory.c_str())){
                        // 目录存在且可以打开
                        // 需要设置PWD环境变量才可以读出对应目录下的文件信息，怀疑是权限问题
                        std::string pwd(getenv("PWD")); 
                        setenv("PWD", directory.c_str(), 1); 
                        dp = opendir(directory.c_str()); 
                        while (entry = readdir(dp)){
                            if(std::string(entry->d_name)!="." && std::string(entry->d_name)!=".."){
                                dir_l(std::string(entry->d_name));
                            }
                        }
                        std::cout << std::endl; 
                        closedir(dp); 
                        chdir(pwd.c_str()); 
                        setenv("PWD", pwd.c_str(), 1); 
                    }
                    else{
                        fprintf(stderr, RED "myshell: dir: %s: No such file or directory or permission denied\n", cmdlist[index+1].c_str()); 
                    }
                }
                else{
                    // 多个参数全为路径
                    directory = cmdlist[index+i]; 
                    if(dp = opendir(directory.c_str())){
                        // 目录存在且可以打开
                        while (entry = readdir(dp)){
                            if(std::string(entry->d_name)!="." && std::string(entry->d_name)!=".."){
                                std::cout << entry->d_name << "\t"; 
                            }
                        }
                        std::cout << std::endl; 
                        closedir(dp); 
                    }
                    else{
                        fprintf(stderr, RED "myshell: dir: %s: No such file or directory or permission denied\n", cmdlist[index+1].c_str()); 
                    }
                }
                if(i<length-1){
                    std::cout << std::endl; 
                }
            }
        }
    }
}

void f_set(int index, int length){
    if(length == 1){
        // 无参数，打印所有环境变量或者增加环境变量
        if((std::string::size_type)cmdlist[index].find('=') == std::string::npos){ 
            // 找不到等号，说明是打印所有环境变量
            extern char **environ; 
            for(int i=0; environ[i]; i++){
                std::cout << environ[i] << std::endl; 
            } 
        }
        else { 
            // 赋值或者创建变量
            std::string name(cmdlist[index], 0, cmdlist[index].find('=')); 
            std::string value(cmdlist[index], cmdlist[index].find('=')+1, cmdlist[index].length()-cmdlist[index].find('=')); 
            // 该环境变量不存在，则添加；存在则重新赋值
            setenv(name.c_str(), value.c_str(), 1); 
        }
    }
    else if(length == 2){
        // 打印特定环境变量的值
        if(!getenv(cmdlist[index+1].c_str())){
            // 该环境变量不存在
            fprintf(stderr, RED "myshell: set: Environment variable not found\n"); 
        }
        else {
            std::cout << getenv(cmdlist[index+1].c_str()) << std::endl; 
        }
    }
    else {
        fprintf(stderr, RED "myshell: set: Wrong number of arguments\n"); 
    }
}

void f_unset(int index, int length){
    if(length == 2){
        // 删除环境变量
        if(!getenv(cmdlist[index+1].c_str())){
            // 该环境变量不存在
            fprintf(stderr, RED "myshell: unset: Environment variable doesn't exist\n"); 
        } 
        else{
            // 删除
            unsetenv(cmdlist[index+1].c_str()); 
        }
    }
    else {
        fprintf(stderr, RED "myshell: unset: Wrong number of arguments\n"); 
    }
}

void f_umask(int index, int length){
    if(length == 1){
        // mask = 旧掩码
        mode_t mask = umask(0); 
        umask(mask); 
        fprintf(stdout, WHITE "%04o\n", mask); 
    }
    else if(length == 2){
        // 判断输入是否合法再改
        if(cmdlist[index+1].length() > 4){
            // 输入过长
            fprintf(stderr,  RED "myshell: umask: %s: Octal number out of range\n", cmdlist[index+1].c_str()); 
        }
        else{
            int illegal = 0, mask = 0; 
            for(int i=0; i<cmdlist[index+1].length(); i++){
                if(!(cmdlist[index+1][i]>='0' && cmdlist[index+1][i]<='8')){
                    // 输入了非法字符
                    illegal = 1; 
                    break; 
                }
                else{
                    // 将十进制处理成八进制
                    mask <<= 3; 
                    mask |= cmdlist[index+1][i]-'0'; 
                }
            }
            if(illegal){
                fprintf(stderr,  RED "myshell: umask: %s: Octal number out of range\n", cmdlist[index+1].c_str()); 
            }
            else{
                umask(mask); 
            }
        }
    }
    else{
        fprintf(stderr,  RED "myshell: umask: Too many arguments\n"); 
    }
}

void f_exec(int index, int length){
    extern void execute(int index, int length); 
    if(length == 1){
        fprintf(stderr,  RED "myshell: exec: Too few arguments\n");
    }
    else{
        // 递归调用执行命令的函数
        execute(index+1, length-1); 
        f_exit(0, 1); 
    }
}

void f_test(int index, int length){
    if(length < 4){
        fprintf(stderr, RED "myshell: test: Too few arguments\n");
    }
    else if(length > 4){
        fprintf(stderr, RED "myshell: test: Too many arguments\n");
    }
    else{
        std::string operation = cmdlist[index+2]; 
        std::string operandA = cmdlist[index+1]; 
        std::string operandB = cmdlist[index+3]; 
        // 同时判断操作符以及结果
        if(operation == "=" || operation == "!="){
            // 字符串比较
            int flag = (operation=="=" ? 1 : 0) ^ (operandA==operandB ? 1 : 0); 
            if(flag){
                std::cout << RED << "FALSE" << std::endl; 
            }
            else{
                std::cout << GREEN << "TRUE" << std::endl; 
            }
        }
        else if(operation == "-eq" || operation == "-ne" || operation == "-lt" || \
                operation == "-le" || operation == "-gt" || operation == "-ge"){
            // 整数比较
            if(!is_digit(operandA)){
                // 非整数
                fprintf(stderr, RED "myshell: test: %s: Numeric argument required\n", operandA.c_str());
            }
            else if(!is_digit(operandA)){
                // 非整数
                fprintf(stderr, RED "myshell: test: %s: Numeric argument required\n", operandB.c_str());
            }
            else if(operation == "-eq"){
                if(atoi(operandA.c_str()) == atoi(operandB.c_str())){
                    std::cout << GREEN << "TRUE" << std::endl; 
                }
                else{
                    std::cout << RED << "FALSE" << std::endl;  
                }
            }
            else if(operation == "-ne"){
                if(atoi(operandA.c_str()) != atoi(operandB.c_str())){
                    std::cout << GREEN << "TRUE" << std::endl; 
                }
                else{
                    std::cout << RED << "FALSE" << std::endl;  
                }
            }
            else if(operation == "-lt"){
                if(atoi(operandA.c_str()) < atoi(operandB.c_str())){
                    std::cout << GREEN << "TRUE" << std::endl; 
                }
                else{
                    std::cout << RED << "FALSE" << std::endl;  
                }
            }
            else if(operation == "-le"){
                if(atoi(operandA.c_str()) <= atoi(operandB.c_str())){
                    std::cout << GREEN << "TRUE" << std::endl; 
                }
                else{
                    std::cout << RED << "FALSE" << std::endl;  
                }
            }
            else if(operation == "-gt"){
                if(atoi(operandA.c_str()) > atoi(operandB.c_str())){
                    std::cout << GREEN << "TRUE" << std::endl; 
                }
                else{
                    std::cout << RED << "FALSE" << std::endl;  
                }
            }
            else {
                if(atoi(operandA.c_str()) >= atoi(operandB.c_str())){
                    std::cout << GREEN << "TRUE" << std::endl; 
                }
                else{
                    std::cout << RED << "FALSE" << std::endl;  
                }
            }
        }
        else{
            fprintf(stderr, RED "myshell: test: %s: Unknown operator\n", operation.c_str());
        }
    }
}

void f_shift(int index, int length){
    if(length <= 2){
        if(length == 1 || is_digit(cmdlist[index+1])){
            // 默认一位
            int shift; 
            if(length == 1){
                shift = 1; 
            }
            else{
                shift = atoi(cmdlist[index+1].c_str());
            }
            char inputbuf[128] = {0};
            std::cin.getline(inputbuf, 123);  
            // 处理输入
            std::istringstream inputbuffer(inputbuf);
            std::string tmp;  
            std::vector<std::string> input;
            while(inputbuffer >> tmp){
                input.push_back(tmp); 
            } 
            // 输出
            if(shift > input.size()){
                std::cout << std::endl; 
            }
            else{
                for(int i=shift; i<input.size(); i++){
                    std::cout << input[i] << " " ; 
                }
                std::cout << std::endl; 
            }
        }
        else{
            fprintf(stderr,  RED "myshell: shift: Numeric argument required\n");
        }
    }
    else{
        fprintf(stderr,  RED "myshell: shift: Too many arguments\n");
    }
}

void f_time(int index, int length){
    if(length>1){
        fprintf(stderr,  RED "myshell: time: Too many arguments\n"); 
    }
    else {
        time_t current, tmp; 
        const char *week[7] = {"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"}; 
        // 得到秒数
        time(&current); 
        // 将秒数转化为可读时间 
        std::string current_time = asctime(localtime(&current)); 
        current_time.replace(current_time.find("\n"), 1, " "); 
        // 得到格林威治时间
        tmp = mktime(gmtime(&current)); 
        // 最后一个输出的计算在计算时区
        std::cout << current_time << "UTC" << std::showpos << (current-tmp)/3600 << std::endl; 
        // 取消输出正负号
        std::cout.unsetf(std::ios::showpos); 
    }
}

void f_pwd(int index, int length){
    if(length>1){
        fprintf(stderr,  RED "myshell: pwd: Too many arguments\n"); 
    }
    else {
        // 获得环境变量的值并打印
        std::string path = getenv("PWD"); 
        std::cout << path << std::endl; 
    } 
}

void f_echo(int index, int length){
    for(int i=1; i<length; i++){
        std::cout << cmdlist[index+i] << " "; 
    }
    std::cout << std::endl; 
}

void f_cd(int index, int length){
    if(length == 1){
        // 无参数，显示当前目录
        std::string path = getenv("PWD");
        std::cout << path << std::endl; 
    }
    else if(length > 2){
        // 参数过多
        fprintf(stderr, RED "myshell: cd: Too many arguments\n"); 
    }
    else {
        std::string dir; 
        // 相对路径处理
        rtoa_path(dir, cmdlist[index+1]); 
        // 切换目录
        if(!chdir(dir.c_str())){
            // 切换目录成功
            setenv("PWD", dir.c_str(), 1); 
        }
        else{
            // 目录不存在
            fprintf(stderr, RED "myshell: cd: %s: No such file or directory or permission denied\n", cmdlist[index+1].c_str()); 
        }
    }
}

void f_exit(int index, int length){
    if(length>1){
        fprintf(stderr,  RED "myshell: exit: Too many arguments\n"); 
    }
    else {
        free_jobs(); 
        std::cout << "Goodbye" << std::endl; 
        exit(0); 
    } 
}

void f_clr(int index, int length){
    if(length>1){
        fprintf(stderr,  RED "myshell: clr: Too many arguments\n"); 
    }
    else {
        std::cout << CLEAR << std::endl; 
    } 
}

void f_system(int index, int length){
    // 调用system()来执行外部命令
    std::string cmd = cmdlist[index]; 
    for(int i=1; i<length; i++){
        cmd.append(" "); 
        cmd.append(cmdlist[index+i]); 
    }
    system(cmd.c_str()); 
}

void f_help(int index, int length){
    if(length>1){
        fprintf(stderr,  RED "myshell: help: Too many arguments\n"); 
    }
    else {
        std::cout << WHITE << std::endl; 
        std::cout << "----------------------myshell----------------------" << std::endl; 
        std::cout << "----------------developed by " << CYAN << "Cheung" << WHITE << "----------------" << std::endl; 
        std::cout << "本程序尽力还原了一部分shell的功能（具体命令可能不同），支持的内部命令及其用法如下：" << std::endl; 

        std::cout << "1. 变量赋值" << std::endl; 
        std::cout << "作用： 对环境变量重新赋值或者创建新的环境变量（等号前后不能有空格）" << std::endl; 
        std::cout << "参数： 无参数" << std::endl; 
        std::cout << "示例： SCHOOL=zju" << std::endl; 
        std::cout << std::endl; 

        std::cout << "2. bg" << std::endl; 
        std::cout << "作用： 对环境变量重新赋值或者创建新的环境变量（等号前后不能有空格）" << std::endl; 
        std::cout << "参数： 无参数" << std::endl; 
        std::cout << "示例： SCHOOL=zju" << std::endl; 
        std::cout << std::endl; 

        std::cout << "3. cd" << std::endl; 
        std::cout << "作用： 切换工作目录（支持..、.、~）" << std::endl; 
        std::cout << "参数： 无参数时显示当前工作目录，有一个参数时切换工作目录至参数目录下" << std::endl; 
        std::cout << "示例： cd ～" << std::endl; 
        std::cout << std::endl; 

        std::cout << "4. clr" << std::endl; 
        std::cout << "作用： 清空终端" << std::endl; 
        std::cout << "参数： 无参数" << std::endl; 
        std::cout << "示例： clr" << std::endl; 
        std::cout << std::endl; 

        std::cout << "5. dir" << std::endl; 
        std::cout << "作用： 显示目录下的内容（支持..、.、~）" << std::endl; 
        std::cout << "参数： 无参数则显示当前目录下的内容，有参数则显示参数所指目录下的内容；指定参数为-l时输出详细信息，类似于ls -l" << std::endl; 
        std::cout << "示例： dir -l ~" << std::endl; 
        std::cout << std::endl; 

        std::cout << "6. echo" << std::endl; 
        std::cout << "作用： 显示命令后的内容" << std::endl; 
        std::cout << "参数： 无参数则显示空，有参数则显示命令后的内容" << std::endl; 
        std::cout << "示例： echo test" << std::endl; 
        std::cout << std::endl; 

        std::cout << "7. exec" << std::endl; 
        std::cout << "作用： 执行参数代表的命令替换当前进程" << std::endl; 
        std::cout << "参数： 参数即为要执行的命令，可以是内部命令也可以是外部命令" << std::endl; 
        std::cout << "示例： exec ls -l" << std::endl; 
        std::cout << std::endl; 

        std::cout << "8. exit" << std::endl; 
        std::cout << "作用： 退出myshell" << std::endl; 
        std::cout << "参数： 无参数" << std::endl; 
        std::cout << "示例： exit" << std::endl; 
        std::cout << std::endl; 

        std::cout << "9. fg" << std::endl; 
        std::cout << "作用： 将参数指定的进程转为前台执行" << std::endl; 
        std::cout << "参数： 一个参数，指定进程的pid" << std::endl; 
        std::cout << "示例： fg 2466" << std::endl; 
        std::cout << std::endl; 

        std::cout << "10. help" << std::endl; 
        std::cout << "作用： 显示帮助" << std::endl; 
        std::cout << "参数： 无参数" << std::endl; 
        std::cout << "示例： help" << std::endl; 
        std::cout << std::endl; 

        std::cout << "11. jobs" << std::endl; 
        std::cout << "作用： 显示所有的后台进程" << std::endl; 
        std::cout << "参数： 无参数" << std::endl; 
        std::cout << "示例： jobs" << std::endl; 
        std::cout << std::endl; 

        std::cout << "12. pwd" << std::endl; 
        std::cout << "作用： 显示当前的工作目录" << std::endl; 
        std::cout << "参数： 无参数" << std::endl; 
        std::cout << "示例： pwd" << std::endl; 
        std::cout << std::endl; 

        std::cout << "13. set" << std::endl; 
        std::cout << "作用： 显示环境变量（此命令功能与environ重合，因此没有单独写environ命令）" << std::endl; 
        std::cout << "参数： 无参数时显示所有环境变量及其值，一个参数时显示参数代表的环境变量的值" << std::endl; 
        std::cout << "示例： set SHELL" << std::endl; 
        std::cout << std::endl; 

        std::cout << "13. set" << std::endl; 
        std::cout << "作用： 显示环境变量（此命令功能与environ重合，因此没有单独写environ命令）；对环境变量赋值可以用等式完成" << std::endl; 
        std::cout << "参数： 无参数时显示所有环境变量及其值，一个参数时显示参数代表的环境变量的值" << std::endl; 
        std::cout << "示例： set SHELL" << std::endl; 
        std::cout << std::endl; 

        std::cout << "14. shift" << std::endl; 
        std::cout << "作用： 输入命令后从标准输入读取变量，将输入变量左移后输出" << std::endl; 
        std::cout << "参数： 无参数时默认左移1位，有参数时参数制定移动多少位" << std::endl; 
        std::cout << "示例： shift 2" << std::endl; 
        std::cout << std::endl; 

        std::cout << "15. test" << std::endl; 
        std::cout << "作用： 进行字符串或者整数的比较" << std::endl; 
        std::cout << "参数： 参数代表要进行比较的表达式" << std::endl; 
        std::cout << "示例： test zju = thu" << std::endl; 
        std::cout << "示例： test 123 -eq 321" << std::endl; 
        std::cout << std::endl; 

        std::cout << "16. time" << std::endl; 
        std::cout << "作用： 显示当前的日期、时间与时区" << std::endl; 
        std::cout << "参数： 无参数" << std::endl; 
        std::cout << "示例： time" << std::endl; 
        std::cout << std::endl; 

        std::cout << "17. umask" << std::endl; 
        std::cout << "作用： 显示掩码或者修改掩码" << std::endl; 
        std::cout << "参数： 无参数时显示掩码，有一个参数时修改掩码" << std::endl; 
        std::cout << "示例： umask 7777" << std::endl; 
        std::cout << std::endl; 

        std::cout << "18. unset" << std::endl; 
        std::cout << "作用： 删除环境变量" << std::endl; 
        std::cout << "参数： 有一个参数指定环境变量名" << std::endl; 
        std::cout << "示例： unset SCHOOL" << std::endl; 

        std::cout << "---------------------------------------------------" << std::endl; 
        std::cout << "本程序支持的其他功能如下：" << std::endl; 
        std::cout << "1. 执行外部命令" << std::endl; 
        std::cout << "作用： 除去上述提到的内部命令，本程序还可以执行shell的其余不同名指令，执行时会自动为其创建子进程" << std::endl; 
        std::cout << "示例： ls -l" << std::endl; 
        std::cout << std::endl; 

        std::cout << "2. 执行脚本文件" << std::endl; 
        std::cout << "作用： 通过命令行执行该程序时，可以通过参数指定程序将要执行的脚本文件" << std::endl; 
        std::cout << "示例： ./myshell test.sh" << std::endl; 
        std::cout << std::endl; 

        std::cout << "3. 重定向" << std::endl; 
        std::cout << "作用： 在myshell内输入命令时，支持进行标准输入、标准输出和标准错误重定向" << std::endl; 
        std::cout << "示例： grep \"zju\" < in" << std::endl; 
        std::cout << "示例： ls -l 1> out" << std::endl; 
        std::cout << "示例： ls -l 2> err" << std::endl; 
        std::cout << std::endl; 

        std::cout << "4. 管道" << std::endl; 
        std::cout << "作用： 在myshell内输入命令时，支持进行多层管道操作，如shell一般" << std::endl; 
        std::cout << "示例： ls -l | grep \"rwx\" | grep \"test\"" << std::endl; 
        std::cout << std::endl; 

        std::cout << "5. 后台执行" << std::endl; 
        std::cout << "作用： 在myshell内输入命令时，支持进行后台执行，在命令的最后输入&即可" << std::endl; 
        std::cout << "示例： sleep 5 &" << std::endl; 
        std::cout << std::endl; 

        std::cout << "6. 中断执行" << std::endl; 
        std::cout << "作用： 在myshell内外部命令执行时，支持进行中断，在命令执行时按下Ctrl+Z即可；此后可以通过bg或者fg命令继续执行" << std::endl; 
        std::cout << "示例： Ctrl+Z" << std::endl; 
        std::cout << CANCEL << std::endl; 
    } 
}
// myshell.cpp
// 张沛全 3190102214

#include"myshell.h"
#include"commands.h"

// 用户名 域名 主目录路径
std::string username, hostname, home; 
// 翻译好的命令
std::vector<std::string> cmdlist; 
// 进程表的地址、数量以及共享内存ID
job* jobs;
int* jobnum;
int shmID;
// 输入命令的标志位
int flag = 0; 
// 信号处理函数结构体
static struct sigaction siga; 

// 打印提示信息
void showprompt(){
    std::string path = getenv("PWD"); 
    if(path.find(home) == 0){
        path = path.replace(path.find(home), home.length(), "~"); 
    } 
    std::cout << YELLOW << username << "@" << hostname << WHITE << ':' << CYAN << path << WHITE << "$ " << CANCEL; 
    return ;
}

// 翻译输入的命令并选择执行
int interpreter(char *cmd_char){
    std::istringstream cmd(cmd_char);
    std::string tmp;  

    // 忽略掉多余的空格
    while(cmd >> tmp){
        cmdlist.push_back(tmp); 
    }

    // interpret
    int cmdlist_length = cmdlist.size(), cmdindex = 0, cmdlength = 0; 
    std::vector<std::pair<int, int>>cmdinfo; 
    for(int i=0; i<cmdlist_length; i++){
        if(cmdlist[i] == "<"){
            // 输入重定向
            flag |= IN_RD; 
            i++; 
            if(!freopen(cmdlist[i].c_str(), "r", stdin)){
                fprintf(stderr, RED "myshell: stdin: No such file\n"); 
                flag = 0; 
                cmdlist.clear(); 
                return -1; 
            }
            if(cmdlength){
                // 保存单个命令的起始下标与命令长度
                cmdinfo.push_back(std::make_pair(cmdindex, cmdlength)); 
                cmdindex = i+1; 
                cmdlength = 0; 
            }
        }
        else if(cmdlist[i] == "1>" || cmdlist[i] == ">"){
            // 输出重定向
            flag |= OUT_RD; 
            i++; 
            freopen(cmdlist[i].c_str(), "w+", stdout); 
            if(cmdlength){
                // 保存单个命令的起始下标与命令长度
                cmdinfo.push_back(std::make_pair(cmdindex, cmdlength)); 
                cmdindex = i+1; 
                cmdlength = 0; 
            } 
        }
        else if(cmdlist[i] == "1>>" || cmdlist[i] == ">>"){
            // 输出追加重定向
            flag |= OUT_RD_APP; 
            i++; 
            freopen(cmdlist[i].c_str(), "a+", stdout);
            if(cmdlength){
                // 保存单个命令的起始下标与命令长度
                cmdinfo.push_back(std::make_pair(cmdindex, cmdlength)); 
                cmdindex = i+1; 
                cmdlength = 0; 
            }
        }
        else if(cmdlist[i] == "2>"){
            // 错误重定向
            flag |= ERR_RD; 
            i++; 
            freopen(cmdlist[i].c_str(), "w+", stderr); 
            if(cmdlength){
                // 保存单个命令的起始下标与命令长度
                cmdinfo.push_back(std::make_pair(cmdindex, cmdlength)); 
                cmdindex = i+1; 
                cmdlength = 0; 
            }
        }
        else if(cmdlist[i] == "2>>"){
            // 错误追加重定向
            flag |= ERR_RD_APP; 
            i++; 
            freopen(cmdlist[i].c_str(), "a+", stderr);
            if(cmdlength){
                // 保存单个命令的起始下标与命令长度
                cmdinfo.push_back(std::make_pair(cmdindex, cmdlength)); 
                cmdindex = i+1; 
                cmdlength = 0; 
            }
        }
        else if(cmdlist[i] == "|"){
            // 管道操作
            flag |= IS_PIPE; 
            if(cmdlength){
                cmdinfo.push_back(std::make_pair(cmdindex, cmdlength)); 
                cmdindex = i+1; 
                cmdlength = 0; 
            }
        }
        else if(i == cmdlist_length-1 && cmdlist[i] == "&"){
            // 后台执行
            flag |= IS_BG; 
        }
        else{
            cmdlength++; 
        }
        // 翻译到最后，要把未记录的单个命令的信息记录下来
        if(i == cmdlist_length - 1 && cmdlength){
            cmdinfo.push_back(std::make_pair(cmdindex, cmdlength));
        }
    }
    // 执行
    if(flag & IS_PIPE){
        // 有管道
        executepipe(flag, cmdinfo, 0);
    }
    else{
        // 无管道
        execute(cmdinfo[0].first, cmdinfo[0].second); 
    }
    // 还原
    if(flag & IN_RD){
        fclose(stdin); 
        std::cin.clear(); 
        std::cin.sync(); 
        freopen("/dev/tty", "r", stdin);  
    }
    if(flag & OUT_RD || flag & OUT_RD_APP){
        fclose(stdout); 
        freopen("/dev/tty", "w", stdout); 
    }
    if(flag & ERR_RD || flag & ERR_RD_APP){
        fclose(stderr); 
        freopen("/dev/tty", "w", stderr); 
    }
    flag = 0; 
    cmdlist.clear(); 
    return 0;
}

// 执行内部命令并返回0，当命令为外部命令时返回-1
int execute_builtin(int index, int length){
    if(cmdlist[index] == "bg"){
        f_bg(index, length); 
    }
    else if(cmdlist[index] == "cd"){
        f_cd(index, length); 
    }
    else if(cmdlist[index] == "clr"){
        f_clr(index, length); 
    }
    else if(cmdlist[index] == "dir"){
        f_dir(index, length); 
    }
    else if(cmdlist[index] == "echo"){
        f_echo(index, length); 
    }
    else if(cmdlist[index] == "exec"){
        f_exec(index, length); 
    }
    else if(cmdlist[index] == "exit"){
        f_exit(index, length); 
    }
    else if(cmdlist[index] == "fg"){
        f_fg(index, length); 
    }
    else if(cmdlist[index] == "help"){
        f_help(index, length); 
    }
    else if(cmdlist[index] == "jobs"){
        f_jobs(index,length); 
    }
    else if(cmdlist[index] == "pwd"){
        f_pwd(index, length); 
    }
    else if(cmdlist[index] == "set" || (std::string::size_type)cmdlist[index].find('=') != std::string::npos){
        f_set(index, length); 
    }
    else if(cmdlist[index] == "shift"){
        f_shift(index, length); 
    }
    else if(cmdlist[index] == "test"){
        f_test(index, length); 
    }
    else if(cmdlist[index] == "time"){
        f_time(index, length); 
    }
    else if(cmdlist[index] == "umask"){
        f_umask(index, length); 
    }
    else if(cmdlist[index] == "unset"){
        f_unset(index, length); 
    }
    else{
        return -1;
    }
    return 0; 
}

// 执行命令
void execute(int index, int length){
    // 无管道
    if(execute_builtin(index, length)){
        // 处理外部命令
        pid_t pid = fork(); 
        if(pid < 0){
            // 出错
            fprintf(stderr, RED "myshell: fail to create a child process\n"); 
            return ;
        }
        else if(!pid){
            // 子进程
            // 添加环境变量
            setenv("PARENT", "/home/cheung/Desktop/code/myshell", 1); 
            // 执行外部命令
            f_system(index, length); 
            exit(0); 
        }
        else{
            // 主进程
            std::string jobname = cmdlist[index]; 
            for(int i=1; i<length; i++){
                jobname.append(" "); 
                jobname.append(cmdlist[index+i]); 
            }
            if(flag & IS_BG){
                // 后台进程
                addjob(pid, jobname, BG, RUNNING);
                // kill(pid, SIGSTOP);  
                // 不等待
                waitpid(pid, NULL, WNOHANG); 
                const int job_num = *jobnum; 
                int bgid = 0; 
                for(int i=0; i<job_num; i++){
                    if(jobs[i].type == BG){
                        bgid++; 
                    }
                }
                std::cout << WHITE << '[' << bgid << "] " << pid << CANCEL << std::endl; 
            }
            else{
                addjob(pid, jobname, FG, RUNNING); 
                // 等待
                waitpid(pid, NULL, WUNTRACED); 
            }
        }
    }
} 

// 递归执行带有管道的命令
void executepipe(int flag, std::vector<std::pair<int, int>>&cmdinfo, int level){
    // 最后一个单个命令，不再需要创建管道
    if(level == cmdinfo.size()-1){
        if(execute_builtin(cmdinfo[level].first, cmdinfo[level].second)){
            f_system(cmdinfo[level].first, cmdinfo[level].second); 
        }
        return ;
    }
    int pipeFD[2];

    // 创建管道
    if(pipe(pipeFD) < 0){
        fprintf(stderr, RED "myshell: Fail to create pipes\n"); 
        return ; 
    }

    pid_t pid = fork(); 
    if(pid < 0){
        // 出错
        fprintf(stderr, RED "myshell: fail to create a child process\n"); 
        return ;
    }
    else if(!pid){
        // 子进程，第一个子进程向管道输出数据，重定向标准输出
        close(pipeFD[0]);
        dup2(pipeFD[1], 1); 
        close(pipeFD[1]);  
        if(execute_builtin(cmdinfo[level].first, cmdinfo[level].second)){
            f_system(cmdinfo[level].first, cmdinfo[level].second); 
        }
        exit(0); 
    }
    else{
        // 主进程
        int status; 
        waitpid(pid, &status, 0); 
        // 从管道读取数据，重定向标准输入
        close(pipeFD[1]);
        dup2(pipeFD[0], 0); 
        close(pipeFD[0]); 
        // 递归执行 
        executepipe(flag, cmdinfo, level+1); 
        // 恢复标准输入
        std::cin.clear(); 
        std::cin.sync(); 
        freopen("/dev/tty", "r", stdin);  
    }

    return ; 
}

// 初始化函数
void init(){
    // 初始化部分环境变量
    username = getenv("LOGNAME"); 
    home = getenv("HOME"); 
    struct utsname tmp;
    uname(&tmp); 
    hostname = tmp.nodename; 
    setenv("shell", "/home/cheung/Desktop/code/myshell", 1); 
    // 初始化进程表
    init_jobs(); 
    // 初始化信号处理函数
    siga.sa_sigaction = signal_handler; 
    siga.sa_flags |= SA_RESTART; 
    siga.sa_flags |= SA_SIGINFO; 
    sigemptyset(&siga.sa_mask); 
    sigaction(SIGCHLD, &siga, NULL); 
    sigaction(SIGTSTP, &siga, NULL); 
    sigaction(SIGSTOP, &siga, NULL); 
}

int main(int argc, char **argv){
    init(); 
    while(true){
        if(argc == 1){
            char cmd[64]; 
            showprompt(); 
            // std::cin.getline(cmd, 64); 
            if(fgets(cmd, 63, stdin))
            {
                interpreter(cmd);  
            } 
            std::cin.clear(); 
            std::cin.sync(); 
        }
        else{
            // 执行外部文件
            FILE *fp; 
            char cmd[64]; 
            // 打开文件
            if(!(fp = fopen(argv[1], "r"))){
                fprintf(stderr, RED "myshell: %s: Fail to open the file\n", argv[1]); 
                free_jobs(); 
                exit(1); 
            }
            while (fgets(cmd, 63, fp))
            {
                interpreter(cmd);  
            }
            fclose(fp); 
            free_jobs(); 
            exit(0); 
        }
        
    }
    return 0; 
}
# Makefile
# 张沛全 3190102214

CC = g++
OBJECTS = myshell.o commands.o
SOURCES = myshell.cpp commands.cpp
TARGET = myshell
# HEADERS = 
$(TARGET): $(OBJECTS)
	$(CC) $(OBJECTS) -o $(TARGET) -lm
commands.o: commands.cpp base.h commands.h
	$(CC) -c commands.cpp
myshell.o: myshell.cpp myshell.h base.h commands.h
	$(CC) -c myshell.cpp
clean: 
	rm $(OBJECTS) $(TARGET)